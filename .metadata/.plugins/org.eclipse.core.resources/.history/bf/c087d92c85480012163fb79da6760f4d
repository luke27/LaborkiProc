//g³ówny Vertex Shader programu
#version 100

uniform mat4 modelMatrix; //macierz modelu
uniform mat4 viewMatrix; //macierz widoku
uniform mat4 projectionMatrix; //mcierz projekcji
uniform mat3 viewRotMatrix; //sk³adnik roatcji macierzy widoku
uniform mat3 modelRotMatrix; //sk³adnik rotacji macierzy modelu
uniform vec3 lightPosition; //pozycja œwiat³a
attribute vec3 a_vertex; // wppó³rzêdna wierzcho³ka
attribute vec2 a_texCoord; //koordynaty tekstur
attribute vec3 a_normal; //noramlne
varying vec2 v_texCoord; //tex coordy dla FS
varying vec3 v_normal; //normalne dla FS
varying vec3 v_normalSurface; //mormalna do powierzchni we wspó³rzêdnych oka
varying vec3 v_lightDir; //kierunek œwiat³a

//funkcje
mat3 calculateRotateMatrix();
mat4 calculateMVP();
mat4 calculateMV();
vec3 calculateLightDir(mat4 mv);

void main()
{
	v_texCoord = a_texCoord;
	v_normal = a_normal;

	mat4 mvp = calculateMVP();

	mat3 normalMatrix = calculateRotateMatrix();
	mat4 mv = calculateMV();

	v_normalSurface = normalMatrix * v_normal;
	v_lightDir = calculateLightDir(mv);

	gl_Position = mvp * vec4(a_vertex, 1.0);
}

//obliczenie macierzy rotacji
mat3 calculateRotateMatrix()
{
	return viewRotMatrix * modelRotMatrix;
}

//obliczenie macierzy model-widok-projekcja
mat4 calculateMVP()
{
	mat4 world = mat4(1.0, 0.0, 0.0, 0.0,
					  0.0, 1.0, 0.0, 0.0,
				      0.0, 0.0, 1.0, 0.0,
				      0.0, 0.0, 0.0, 1.0);
	return projectionMatrix * viewMatrix * modelMatrix * world ; //liczenie macierzy model-widok-projekcja
}

//obliczenie macierzy model-widok
mat4 calculateMV()
{
	return viewMatrix * modelMatrix;
}

//obliczenie wektora wskazuj¹cego kierunek œwiat³a
vec3 calculateLightDir(mat4 mv)
{
	vec4 vtmp = mv * vec4(a_vertex, 1.0);
	vec3 vtmp1 = vtmp.xyz / vtmp.w;

	return normalize(lightPosition * vtmp1);
}